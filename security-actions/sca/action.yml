name: SCA
description: Generates SBOM and vulnerability report
author: 'Kong'
inputs:
  asset_prefix:
    description: 'prefix for generated scan artifacts'
    required: false
    default: ''
  dir:
    description: 'Specify a directory to be scanned. This is mutually exclusive to file and image'
    required: false
    default: ''
  file:
    description: 'Specify a file to be scanned. This is mutually exclusive to dir and image'
    required: false
    default: ''
  config:
    description: 'file path to syft custom configuration'
    required: false
  fail_build:
    description: 'fail the build if the vulnerability is above the severity cutoff'
    required: false
    default: false
    type: choice
    options:
    - 'true'
    - 'false'
  github-token:
    description: "Authorized secret GitHub Personal Access Token. Defaults to github.token"
    required: false
    default: ${{ github.token }}
  upload-sbom-release-assets:
    description: 'specify to only upload sboms to GH release assets'
    required: false
    default: false
    type: choice
    options:
    - 'true'
    - 'false'
  codeql_upload:
    description: 'Toggle to upload results to Github code scanning for public repositories'
    required: false
    default: false
    type: choice
    options:
    - 'true'
    - 'false'
  grype_db_cache:
    description: 'GitHub repository containing Grype DB cache (format: owner/repo@ref). Database should be named `db_v*.tar.zst` on the default branch.'
    required: false
  grype_db_cache_token:
    description: 'Token for accessing `grype_db_cache`.'
    required: false
  force_cache_refresh:
    description: 'Force ignoring cached Grype DB and re-import/update it'
    required: false
    default: 'false'
    type: choice
    options:
      - 'true'
      - 'false'

# Outputs to be consumed by others using this SCA action
outputs:
  global-enforce-build-failure:
    description: 'Globally fail the build on failure. Overrides fail_build when set'
    value: ${{ steps.meta.outputs.global_enforce_build_failure }}
  cis-json-report:
    description: 'docker-cis json report'
    value: ${{ steps.meta.outputs.cis_json_file }}
  grype-json-report:
    description: 'vulnerability json report'
    value: ${{ steps.meta.outputs.grype_json_file }}
  grype-sarif-report:
    description: 'vulnerability sarif report'
    value: ${{ steps.meta.outputs.grype_sarif_file }}
  sbom-spdx-report:
    description: 'SBOM spdx report'
    value: ${{ steps.meta.outputs.sbom_spdx_file }}
  sbom-cyclonedx-report:
    description: 'SBOM cyclonedx report'
    value: ${{ steps.meta.outputs.sbom_cyclonedx_file }}

runs:
  using: composite
  steps:

    - name: Set Scan Job Metadata
      shell: bash
      id: meta
      env:
        DIR: ${{ inputs.dir }}
        FILE: ${{ inputs.file }}
        ASSET_PREFIX: ${{ inputs.asset_prefix }}
      run: $GITHUB_ACTION_PATH/scripts/scan-metadata.sh

    # Must upload artifact for output file parameter to have effect
    - name: Generate SPDX SBOM Using Syft
      uses: anchore/sbom-action@f8bdd1d8ac5e901a77a92f111440fdb1b593736b # v0.20.6
      id: sbom_spdx
      with:
        config: ${{ inputs.config }}
        path: ${{ steps.meta.outputs.scan_dir }}
        file: ${{ steps.meta.outputs.scan_file }}
        format: spdx-json
        artifact-name: ${{ steps.meta.outputs.sbom_spdx_file }}
        output-file: ${{ steps.meta.outputs.sbom_spdx_file }}
        upload-artifact: true
        upload-release-assets: ${{ inputs.upload-sbom-release-assets }}
        dependency-snapshot: false
        github-token: ${{ inputs.github-token }}

    - name: Generate CycloneDX SBOM Using Syft
      uses: anchore/sbom-action@f8bdd1d8ac5e901a77a92f111440fdb1b593736b # v0.20.6
      id: sbom_cyclonedx
      with:
        config: ${{ inputs.config }}
        path: ${{ steps.meta.outputs.scan_dir }}
        file: ${{ steps.meta.outputs.scan_file }}
        format: cyclonedx-json
        artifact-name: ${{ steps.meta.outputs.sbom_cyclonedx_file }}
        output-file: ${{ steps.meta.outputs.sbom_cyclonedx_file }}
        upload-artifact: true
        upload-release-assets: ${{ inputs.upload-sbom-release-assets }}
        dependency-snapshot: false
        github-token: ${{ inputs.github-token }}

    - name: Check SBOM files existence
      id: sbom_report
      shell: bash
      run: |
        echo "::group::Check for SBOM files existence"
        spdx_file=${{ steps.meta.outputs.sbom_spdx_file }}
        cyclonedx_file=${{ steps.meta.outputs.sbom_cyclonedx_file }}
        if [[ -f "${spdx_file}" ]] && [[ -f "${cyclonedx_file}" ]]; then
          echo "SPDX and CYCLONEDX SBOM files exist"
          echo "files_exists=true" >> $GITHUB_OUTPUT
        else
          echo "::error::SBOM report files missing"
          echo "files_exists=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "::endgroup::"

    # Default Action supported Cache DB is disabled to avoid pulling from upstream and failing if unavailablein Git Cache.
    # Instead handled explicitly to try from mirror before reaching upstream for more realiability
    - name: Install Grype
      id: grype_install
      uses: anchore/scan-action/download-grype@f6601287cdb1efc985d6b765bbf99cb4c0ac29d8 # v7.0.0
      with:
        cache-db: false

    - name: Get Grype version and DB schema installed by Anchore Action
      id: grype_metadata
      shell: bash
      run: |
        # Set grype executable path from action output
        grype_cmd=${{ steps.grype_install.outputs.cmd }}
        grype_version=$($grype_cmd version -o json | jq -r '.version')
        grype_db_schema=$($grype_cmd version -o json | jq '.supportedDbSchema')

        echo "grype_cmd=${{ steps.grype_install.outputs.cmd }}" >> $GITHUB_OUTPUT
        echo "grype_db_schema=${grype_db_schema}" >> $GITHUB_OUTPUT
        echo "grype_version=${grype_version}" >> $GITHUB_OUTPUT

        echo "::group::Grype version and DB schema"
        echo "grype_version=${grype_version}"
        echo "grype_db_schema=${grype_db_schema}"
        echo "::endgroup::"
      env:
        grype: ${{ steps.grype.outputs.grype-path }}

    - name: Get current date
      id: date
      shell: bash
      run: echo "date=$(date +'%Y-%m-%d')" >> $GITHUB_OUTPUT

    # Explicitly check for Grype DB in Git Cache
    - name: Check Git Cache for Grype DB
      id: grype_db_git_cache
      uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4.2.4
      with:
        # Grype cache files are stored in `~/.cache/grype/db` on Linux/macOS
        path: ~/.cache/grype/db
        # Given the DB should not be less than 5 days old let's refetch it at least once per day
        key: |
          cache_grype_db_v${{ steps.grype_metadata.outputs.grype_db_schema }}_${{ steps.date.outputs.date }}

    - name: Validate cached Grype DB
      id: grype_db_cached_status
      if: steps.grype_db_git_cache.outputs.cache-hit == 'true'
      shell: bash
      run: |
        echo "::group::Validate cached Grype DB"
        set +e
        ${{ steps.grype_metadata.outputs.grype_cmd }} db status
        status=$?
        set -e
        if [[ "$status" -ne 0 ]]; then
          echo "Cached Grype DB is INVALID; will refetch."
          echo "valid=false" >> $GITHUB_OUTPUT
        else
          echo "Cached Grype DB is valid."
          echo "valid=true" >> $GITHUB_OUTPUT
        fi
        echo "::endgroup::"

    - name: Compute effective Grype DB cache status
      id: grype_db_effective_cache
      shell: bash
      run: |
        echo "::group::Compute effective grype DB cache"
        HIT="${{ steps.grype_db_git_cache.outputs.cache-hit }}"
        VALID="${{ steps.grype_db_cached_status.outputs.valid }}"
        FORCE="${{ inputs.force_cache_refresh }}"

        if [[ "$FORCE" == "true" ]]; then
          echo "Forcing Grype DB refresh; treating cache as miss/invalid."
          echo "hit=false" >> $GITHUB_OUTPUT
          echo "valid=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        if [[ "$HIT" == "true" ]]; then
          echo "hit=true" >> $GITHUB_OUTPUT
        else
          echo "hit=false" >> $GITHUB_OUTPUT
        fi

        if [[ "$VALID" == "true" ]]; then
          echo "valid=true" >> $GITHUB_OUTPUT
        else
          echo "valid=false" >> $GITHUB_OUTPUT
        fi
        echo "::endgroup::"

    - name: List cache contents
      id: grype_cache_dir
      shell: bash
      run: |
        echo "::group::List cache contents"
        ls -laR ~/.cache/
        echo "::endgroup::"

    - name: Setup Grype DB from cache repository
      if: (steps.grype_db_effective_cache.outputs.hit != 'true' || steps.grype_db_effective_cache.outputs.valid != 'true') && inputs.grype_db_cache != ''
      shell: bash
      run: |
        set -euo pipefail
        # Import Grype DB
        # Expected to be recent and kept up-to-date every 12 hours for specific schema
        ${{steps.grype_metadata.outputs.grype_cmd}} db import grype-db-cache/db/db_v${{ steps.grype_metadata.outputs.grype_db_schema }}.tar.zst
        rm -rf grype-db-cache
        ${{steps.grype_metadata.outputs.grype_cmd}} db status

     # Explicitly check for Grype DB in specified mirror
    - name: Parse Grype DB cache input
      if: (steps.grype_db_effective_cache.outputs.hit != 'true' || steps.grype_db_edffective_cache.outputs.valid != 'true') && inputs.grype_db_cache != ''
      shell: bash
      id: parse_grype_cache
      run: |
        REPO=$(echo "${{ inputs.grype_db_cache }}" | cut -d'@' -f1)
        REF=$(echo "${{ inputs.grype_db_cache }}" | cut -d'@' -f2)
        echo "repository=${REPO}" >> $GITHUB_OUTPUT
        echo "ref=${REF}" >> $GITHUB_OUTPUT

    - name: Checkout Grype DB cache Repo
      if: (steps.grype_db_effective_cache.outputs.hit != 'true'  || steps.grype_db_effective_cache.outputs.valid != 'true') && inputs.grype_db_cache != ''
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      with:
        repository: ${{ steps.parse_grype_cache.outputs.repository }}
        ref: ${{ steps.parse_grype_cache.outputs.ref }}
        path: grype-db-cache
        token: ${{ inputs.grype_db_cache_token }}

    - name: Setup Grype DB from cache repository
      if: (steps.grype_db_effective_cache.outputs.hit != 'true' || steps.grype_db_effective_cache.outputs.valid != 'true') && inputs.grype_db_cache != ''
      shell: bash
      run: |
        set -euo pipefail
        # Import Grype DB
        # Expected to be recent and kept up-to-date every 12 hours for specific schema
        ${{steps.grype_metadata.outputs.grype_cmd}} db import grype-db-cache/db/db_v${{ steps.grype_metadata.outputs.grype_db_schema }}.tar.zst
        rm -rf grype-db-cache
        ${{steps.grype_metadata.outputs.grype_cmd}} db status

    # Default: Grype DB update from upstream
    - name: Grype DB Update from upstream
      if: (steps.grype_db_effective_cache.outputs.hit != 'true' || steps.grype_db_effective_cache.outputs.valid != 'true') && inputs.grype_db_cache == ''
      id: grype_db_update
      shell: bash
      run: |
        echo "::group::Update Grype DB"
        set -euo pipefail
        ${{steps.grype_metadata.outputs.grype_cmd}} db update -vv
        # Force a DB check to ensure we don't cache an invalid DB
        ${{ steps.grype_metadata.outputs.grype_cmd }} db status
        echo "::endgroup::"

    - name: Check Grype DB Status
      id: grype_db_status
      shell: bash
      run: |
        echo "::group::Print Grype DB status"
        set +e
        ${{steps.grype_metadata.outputs.grype_cmd}} db status
        db_status=$?
        set -e
        if [[ "${db_status}" -ne 0 ]]; then
          msg="Grype DB initialization was not successful. CVE results unavailable due to DB issues"
          if [[ ${FAIL_BUILD} -eq 1 ]]; then
            echo "::error ::${msg}"
            exit ${FAIL_BUILD}
          elif [[ $FAIL_BUILD -eq 0 ]]; then
            echo "::warning ::${msg}"
          fi
        else
          echo "::notice ::Grype DB is updated successfully"
        fi
        echo "db_status=${db_status}" >> $GITHUB_OUTPUT
        echo "::endgroup::"
      env:
        FAIL_BUILD: ${{ (steps.meta.outputs.global_enforce_build_failure == 'true' || inputs.fail_build == 'true') && '1' || '0' }}

    # Don't fail during report generation
    # If previously installed using  Anchore action, finds grype executable
    - name: Vulnerability analysis of SBOM (SARIF format)
      uses: anchore/scan-action@f6601287cdb1efc985d6b765bbf99cb4c0ac29d8 # v7.0.0
      id: grype_analysis_sarif
      if: ${{ steps.sbom_report.outputs.files_exists == 'true' && steps.grype_db_status.outputs.db_status == '0' }}
      with:
        sbom: ${{ steps.meta.outputs.sbom_spdx_file }}
        output-format: sarif
        fail-build: 'false'
        add-cpes-if-none: true
        severity-cutoff: ${{ steps.meta.outputs.global_severity_cutoff }}
        grype-version: ${{ steps.grype_install.outputs.grype_version }}
      env:
        GRYPE_DB_AUTO_UPDATE: false

    # Don't fail during report generation
    # JSON format will report  any ignored rules
    - name: Vulnerability analysis of SBOM (JSON format)
      uses: anchore/scan-action@f6601287cdb1efc985d6b765bbf99cb4c0ac29d8 # v7.0.0
      id: grype_analysis_json
      if: ${{ steps.sbom_report.outputs.files_exists == 'true' && steps.grype_db_status.outputs.db_status == '0' }}
      with:
        sbom: ${{ steps.meta.outputs.sbom_spdx_file }}
        output-format: json
        fail-build: 'false'
        add-cpes-if-none: true
        severity-cutoff: ${{ steps.meta.outputs.global_severity_cutoff }}
        grype-version: ${{ steps.grype_install.outputs.grype_version }}
      env:
        GRYPE_DB_AUTO_UPDATE: false # Use grype db cache from grype step above

    - name: Check vulnerability analysis report existence
      id: grype_report
      shell: bash
      run: |
        echo "::group::Check for Vulnerability report existence"
        sarif_file=${{ steps.grype_analysis_sarif.outputs.sarif }}
        json_file=${{ steps.grype_analysis_json.outputs.json }}
        if [[ -f "${sarif_file}" ]] && [[ -f "${json_file}" ]]; then
          echo "JSON and SARIF CVE files exist"
          echo "files_exists=true" >> $GITHUB_OUTPUT
        else
          echo "::error::Grype report files missing"
          echo "files_exists=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "::endgroup::"

    # Grype CVE Action generates an ./results.sarif or ./results.report and no way to customize output file name
    # Hack to increase readability of grype artifacts attached to workflows and releases
    - name: Rename grype analysis report
      shell: bash
      if: ${{ steps.grype_report.outputs.files_exists == 'true' }}
      run: |
        mv ${{ steps.grype_analysis_sarif.outputs.sarif }} ${{ steps.meta.outputs.grype_sarif_file }}
        mv ${{ steps.grype_analysis_json.outputs.json }} ${{ steps.meta.outputs.grype_json_file }}

    # Upload to GitHub Code Scanning for public repos
    - name: Upload SARIF to GitHub Code Scanning (Public Repos)
      if: ${{ inputs.codeql_upload == 'true' && steps.grype_analysis_sarif.conclusion == 'success' && github.event.repository.visibility == 'public' }}
      continue-on-error: true
      uses: github/codeql-action/upload-sarif@0499de31b99561a6d14a36a5f662c2a54f91beee # v4.31.2
      with:
        sarif_file: ${{ steps.meta.outputs.grype_sarif_file }}
        category: sca

    # Upload artifacts
    - name: Upload grype SARIF analysis report
      if: ${{ steps.grype_analysis_sarif.conclusion == 'success' && steps.grype_report.outputs.files_exists == 'true' }}
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
      with:
        name: ${{ steps.meta.outputs.grype_sarif_file }}
        path: |
          ${{ steps.meta.outputs.grype_sarif_file }}
        if-no-files-found: warn

    - name: Upload grype JSON analysis report
      if: ${{ steps.grype_analysis_json.conclusion == 'success' && steps.grype_report.outputs.files_exists == 'true' }}
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
      with:
        name: ${{ steps.meta.outputs.grype_json_file }}
        path: |
          ${{ steps.meta.outputs.grype_json_file }}
        if-no-files-found: warn

    # Fail based on severity and input parameters
    # Notify grype quick scan results in table format
    # Table format will supress any specified ignore rules
    - name: Inspect Vulnerability analysis (Table format)
      uses: anchore/scan-action@f6601287cdb1efc985d6b765bbf99cb4c0ac29d8 # v7.0.0
      if: ${{ steps.sbom_report.outputs.files_exists == 'true' && steps.grype_db_status.outputs.db_status == '0' }}
      with:
        sbom: ${{ steps.meta.outputs.sbom_spdx_file }}
        output-format: table
        fail-build: ${{ steps.meta.outputs.global_enforce_build_failure == 'true' && steps.meta.outputs.global_enforce_build_failure || inputs.fail_build }}
        add-cpes-if-none: true
        severity-cutoff: ${{ steps.meta.outputs.global_severity_cutoff }}
        grype-version: ${{ steps.grype_install.outputs.grype_version }}
      env:
        GRYPE_DB_AUTO_UPDATE: false # Use grype db cache from grype step above
