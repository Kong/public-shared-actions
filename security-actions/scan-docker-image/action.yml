name: Docker SCA and CIS scan
description: Generates SBOM and vulnerabiity report
author: 'Kong'
inputs:
  asset_prefix:
    description: 'prefix for generated scan artifacts'
    required: false
    default: ''
  image:
    description: 'specify an image to be scanned. Specify registry credentials if the image is remote. Takes priority over dir and file'
    required: false
    default: ''
  tag:
    description: 'specify a docker image tag / release tag / ref to be scanned'
    required: false
    default: ''
  registry_username:
    description: 'docker username to login against private docker registry'
    required: false
  registry_password:
    description: 'docker password to login against private docker registry'
    required: false
  config:
    description: 'file path to syft custom configuration'
    required: false
  fail_build:
    description: 'fail the build if the vulnerability is above the severity cutoff'
    required: false
    default: 'false'
    type: choice
    options:
    - 'true'
    - 'false'
  github-token:
    description: "Authorized secret GitHub Personal Access Token. Defaults to github.token"
    required: false
    default: ${{ github.token }}
  upload-sbom-release-assets:
    description: 'specify to only upload sboms to GH release assets'
    required: false
    default: 'false'
    type: choice
    options:
    - 'true'
    - 'false'
  skip_cis_scan:
    required: false
    default: 'false'
    description: 'Toggle to skip Trivy scan'
    type: choice
    options:
      - 'true'
      - 'false'
  trivy_db_cache:
    description: 'GitHub repository containing Trivy DB cache (format: owner/repo@ref). Database should be named `db.tar.gz` on the default branch.'
    required: false
  trivy_db_cache_token:
    description: 'Token for accessing `trivy_db_cache`.'
    required: false
  by_cve:
    description: 'Specify whether to orient results by CVE rather than GHSA'
    required: false
    default: 'false'
  grype_db_cache:
    description: 'GitHub repository containing Grype DB cache (format: owner/repo@ref). Database should be named `db_v*.tar.zst` on the default branch.'
    required: false
  grype_db_cache_token:
    description: 'Token for accessing `grype_db_cache`.'
    required: false

outputs:
  cis-json-report:
    description: 'docker-cis json report'
    value: ${{ steps.meta.outputs.cis_json_file }}
  grype-json-report:
    description: 'vulnerability json report'
    value: ${{ steps.meta.outputs.grype_json_file }}
  grype-sarif-report:
    description: 'vulnerability sarif report'
    value: ${{ steps.meta.outputs.grype_sarif_file }}
  sbom-spdx-report:
    description: 'SBOM spdx report'
    value: ${{ steps.meta.outputs.sbom_spdx_file }}
  sbom-cyclonedx-report:
    description: 'SBOM cyclonedx report'
    value: ${{ steps.meta.outputs.sbom_cyclonedx_file }}

runs:
  using: composite
  steps:

    - name: Set Scan Job Metadata
      shell: bash
      id: meta
      env:
        IMAGE: ${{ inputs.image }}
        TAG: ${{ inputs.tag }}
        ASSET_PREFIX: ${{ inputs.asset_prefix }}
      run: $GITHUB_ACTION_PATH/scripts/scan-metadata.sh

    # Must upload artifact for output file parameter to have effect
    - name: Generate SPDX SBOM Using Syft
      uses: anchore/sbom-action@f8bdd1d8ac5e901a77a92f111440fdb1b593736b # v0.20.6
      id: sbom_spdx
      with:
        config: ${{ inputs.config }}
        image: ${{ steps.meta.outputs.scan_image }}
        registry-username: ${{ inputs.registry_username }}
        registry-password: ${{ inputs.registry_password }}
        format: spdx-json
        artifact-name: ${{ steps.meta.outputs.sbom_spdx_file }}
        output-file: ${{ steps.meta.outputs.sbom_spdx_file }}
        upload-artifact: true
        upload-release-assets: ${{ inputs.upload-sbom-release-assets }}
        dependency-snapshot: false
        github-token: ${{ inputs.github-token }}

    - name: Generate CycloneDX SBOM Using Syft
      uses: anchore/sbom-action@f8bdd1d8ac5e901a77a92f111440fdb1b593736b # v0.20.6
      id: sbom_cyclonedx
      with:
        config: ${{ inputs.config }}
        image: ${{ steps.meta.outputs.scan_image }}
        registry-username: ${{ inputs.registry_username }}
        registry-password: ${{ inputs.registry_password }}
        format: cyclonedx-json
        artifact-name: ${{ steps.meta.outputs.sbom_cyclonedx_file }}
        output-file: ${{ steps.meta.outputs.sbom_cyclonedx_file }}
        upload-artifact: true
        upload-release-assets: ${{ inputs.upload-sbom-release-assets }}
        dependency-snapshot: false
        github-token: ${{ inputs.github-token }}

    - name: Check SBOM files existence
      id: sbom_report
      shell: bash
      run: |
        echo "::group::Check for SBOM files existence"
        spdx_file=${{ steps.meta.outputs.sbom_spdx_file }}
        cyclonedx_file=${{ steps.meta.outputs.sbom_cyclonedx_file }}
        if [[ -f "${spdx_file}" ]] && [[ -f "${cyclonedx_file}" ]]; then
          echo "SPDX and CYCLONEDX SBOM files exist"
          echo "files_exists=true" >> $GITHUB_OUTPUT
        else
          echo "::error::SBOM report files missing"
          echo "files_exists=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "::endgroup::"

    # Default Action supported Cache DB is disabled to avoid pulling from upstream and failing if unavailablein Git Cache.
    # Instead handled explicitly to try from mirror before reaching upstream for more realiability
    - name: Install Grype
      id: grype_install
      uses: anchore/scan-action/download-grype@568b89d27fc18c60e56937bff480c91c772cd993 # v7.1.0
      with:
        cache-db: false

    - name: Get Grype version and DB schema installed by Anchore Action
      id: grype_metadata
      shell: bash
      run: |
        # Set grype executable path from action output
        grype_cmd=${{ steps.grype_install.outputs.cmd }}
        grype_version=$($grype_cmd version -o json | jq -r '.version')
        grype_db_schema=$($grype_cmd version -o json | jq '.supportedDbSchema')

        echo "grype_cmd=${{ steps.grype_install.outputs.cmd }}" >> $GITHUB_OUTPUT
        echo "grype_db_schema=${grype_db_schema}" >> $GITHUB_OUTPUT
        echo "grype_version=${grype_version}" >> $GITHUB_OUTPUT

        echo "::group::Grype version and DB schema"
        echo "grype_version=${grype_version}"
        echo "grype_db_schema=${grype_db_schema}"
        echo "::endgroup::"
      env:
        grype: ${{ steps.grype.outputs.grype-path }}

    - name: Get current date
      id: date
      shell: bash
      run: echo "date=$(date +'%Y-%m-%d')" >> $GITHUB_OUTPUT

    # Explicitly check for Grype DB in Git Cache
    - name: Check Git Cache for Grype DB
      id: grype_db_git_cache
      uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4.2.4
      with:
        # Grype cache files are stored in `~/.cache/grype/db` on Linux/macOS
        path: ~/.cache/grype/db
        # Given the DB should not be less than 5 days old let's refetch it at least once per day
        key: |
          cache_grype_db_v${{ steps.grype_metadata.outputs.grype_db_schema }}_${{ steps.date.outputs.date }}

    # Explicitly check for Grype DB in specified mirror
    - name: Parse Grype DB cache input
      if: steps.grype_db_git_cache.outputs.cache-hit != 'true' && inputs.grype_db_cache != ''
      shell: bash
      id: parse_grype_cache
      run: |
        REPO=$(echo "${{ inputs.grype_db_cache }}" | cut -d'@' -f1)
        REF=$(echo "${{ inputs.grype_db_cache }}" | cut -d'@' -f2)
        echo "repository=${REPO}" >> $GITHUB_OUTPUT
        echo "ref=${REF}" >> $GITHUB_OUTPUT

    - name: Checkout Grype DB cache Repo
      if: steps.grype_db_git_cache.outputs.cache-hit != 'true' && inputs.grype_db_cache != ''
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      with:
        repository: ${{ steps.parse_grype_cache.outputs.repository }}
        ref: ${{ steps.parse_grype_cache.outputs.ref }}
        path: grype-db-cache
        token: ${{ inputs.grype_db_cache_token }}

    - name: Setup Grype DB from cache repository
      if: steps.grype_db_git_cache.outputs.cache-hit != 'true' && inputs.grype_db_cache != ''
      shell: bash
      run: |
        # Import Grype DB
        # Expected to be recent and kept up-to-date every 12 hours for specific schema
        ${{steps.grype_metadata.outputs.grype_cmd}} db import grype-db-cache/db/db_v${{ steps.grype_metadata.outputs.grype_db_schema }}.tar.zst
        rm -rf grype-db-cache

    # Default: Grype DB update from upstream
    - name: Grype DB Update from upstream
      if: steps.grype_db_git_cache.outputs.cache-hit != 'true' && inputs.grype_db_cache == ''
      id: grype_db_update
      shell: bash
      run: |
        echo "::group::Update Grype DB"
        ${{steps.grype_metadata.outputs.grype_cmd}} db update -vv || true
        echo "::endgroup::"

    - name: Check Grype DB Status
      id: grype_db_status
      shell: bash
      run: |
        echo "::group::Print Grype DB status"
        db_status=$?
        ${{steps.grype_metadata.outputs.grype_cmd}} db status || db_status=$?
        if [[ "${db_status}" -ne 0 ]]; then
          msg="Grype DB initialization was not successful. CVE results unavailable due to DB issues"
          if [[ ${FAIL_BUILD} -eq 1 ]]; then
            echo "::error ::${msg}"
            exit ${FAIL_BUILD}
          elif [[ $FAIL_BUILD -eq 0 ]]; then
            echo "::warning ::${msg}"
          fi
        else
          echo "::notice ::Grype DB is updated successfully"
        fi
        echo "db_status=${db_status}" >> $GITHUB_OUTPUT
        echo "::endgroup::"
      env:
        FAIL_BUILD: ${{ (steps.meta.outputs.global_enforce_build_failure == 'true' || inputs.fail_build == 'true') && '1' || '0' }}

    # Grype is invoked first time ever
    # Don't fail during report generation
    - name: Vulnerability analysis of SBOM
      uses: anchore/scan-action@568b89d27fc18c60e56937bff480c91c772cd993 # v7.1.0
      id: grype_analysis_sarif
      if: ${{ steps.sbom_report.outputs.files_exists == 'true' && steps.grype_db_status.outputs.db_status == '0' }}
      with:
        sbom: ${{ steps.meta.outputs.sbom_spdx_file }}
        output-format: sarif
        fail-build: 'false'
        add-cpes-if-none: true
        severity-cutoff: ${{ steps.meta.outputs.global_severity_cutoff }}
        by-cve: ${{ inputs.by_cve }}
        grype-version: ${{ steps.grype_install.outputs.grype_version }}
      env:
        GRYPE_DB_AUTO_UPDATE: false # Use grype db pointed from grype_db step above

    # Don't fail during report generation
    # JSON format will report  any ignored rules
    - name: Vulnerability analysis of SBOM
      uses: anchore/scan-action@568b89d27fc18c60e56937bff480c91c772cd993 # v7.1.0
      id: grype_analysis_json
      if: ${{ steps.sbom_report.outputs.files_exists == 'true' && steps.grype_db_status.outputs.db_status == '0' }}
      with:
        sbom: ${{ steps.meta.outputs.sbom_spdx_file }}
        output-format: json
        fail-build: 'false'
        add-cpes-if-none: true
        severity-cutoff: ${{ steps.meta.outputs.global_severity_cutoff }}
        by-cve: ${{ inputs.by_cve }}
        grype-version: ${{ steps.grype_install.outputs.grype_version }}
      env:
        GRYPE_DB_AUTO_UPDATE: false # Use grype db pointed from grype_db step above

    - name: Check vulnerability analysis report existence
      id: grype_report
      shell: bash
      run: |
        echo "::group::Check for Vulnerabibility report existence"
        sarif_file=${{ steps.grype_analysis_sarif.outputs.sarif }}
        json_file=${{ steps.grype_analysis_json.outputs.json }}
        if [[ -f "${sarif_file}" ]] && [[ -f "${json_file}" ]]; then
          echo "JSON and SARIF CVE files exist"
          echo "files_exists=true" >> $GITHUB_OUTPUT
        else
          echo "::error::Grype report files missing"
          echo "files_exists=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "::endgroup::"

    # Grype CVE Action generates an ./results.sarif or ./results.report and no way to customize output file name
    # Hack to increase readability of grype artifacts attached to workflows and releases
    - name: Rename grype analysis report
      shell: bash
      run: |
        mv ${{ steps.grype_analysis_sarif.outputs.sarif }} ${{ steps.meta.outputs.grype_sarif_file }}
        mv ${{ steps.grype_analysis_json.outputs.json }} ${{ steps.meta.outputs.grype_json_file }}

    - name: Upload grype analysis report
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
      with:
        name: ${{ steps.meta.outputs.grype_sarif_file }}
        path: |
          ${{ steps.meta.outputs.grype_sarif_file }}
        if-no-files-found: warn

    # Upload grype cve reports
    - name: Upload grype analysis report
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
      with:
        name: ${{ steps.meta.outputs.grype_json_file }}
        path: |
          ${{ steps.meta.outputs.grype_json_file }}
        if-no-files-found: warn

    # Fail based on severity and input parameters
    # Notify grype quick scan results in table format
    # Table format will supress any specified ignore rules
    - name: Inspect Vulnerability analysis of SBOM
      uses: anchore/scan-action@568b89d27fc18c60e56937bff480c91c772cd993 # v7.1.0
      if: ${{ steps.sbom_report.outputs.files_exists == 'true' && steps.grype_db_status.outputs.db_status == '0' }}
      with:
        sbom: ${{ steps.meta.outputs.sbom_spdx_file }}
        output-format: table
        fail-build: ${{ steps.meta.outputs.global_enforce_build_failure == 'true' && steps.meta.outputs.global_enforce_build_failure || inputs.fail_build }}
        add-cpes-if-none: true
        severity-cutoff: ${{ steps.meta.outputs.global_severity_cutoff }}
        by-cve: ${{ inputs.by_cve }}
        grype-version: ${{ steps.grype_install.outputs.grype_version }}
      env:
        GRYPE_DB_AUTO_UPDATE: false # Use grype db pointed from grype_db step above

    - name: Check docker OCI tar existence
      if: ${{ steps.meta.outputs.scan_image != '' }}
      id: docker_tar
      shell: bash
      run: |
        echo "::group::Check for Vulnerabibility report existence"
        docker_archive_file=${{ steps.meta.outputs.scan_image }}
        if [[ -f "${docker_archive_file}" ]]; then
          echo "Docker Archive file exists"
          echo "files_exists=true" >> $GITHUB_OUTPUT
        else
          echo "files_exists=false" >> $GITHUB_OUTPUT
        fi
        echo "::endgroup::"

      # Issue: https://github.com/aquasecurity/trivy/issues/7938
      # Discussion: https://github.com/aquasecurity/trivy/discussions/7668
      # Fix: Refer https://github.com/aquasecurity/trivy/discussions/7951 usign mirror.gcr.io
    - name: Install Trivy
      shell: bash
      run: |
        curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v0.60.0

    - name: Parse Trivy DB cache input
      if: inputs.trivy_db_cache != ''
      shell: bash
      id: parse_trivy_cache
      run: |
        REPO=$(echo "${{ inputs.trivy_db_cache }}" | cut -d'@' -f1)
        REF=$(echo "${{ inputs.trivy_db_cache }}" | cut -d'@' -f2)
        echo "repository=${REPO}" >> $GITHUB_OUTPUT
        echo "ref=${REF}" >> $GITHUB_OUTPUT

    - name: Checkout Trivy DB cache
      if: inputs.trivy_db_cache != ''
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      with:
        repository: ${{ steps.parse_trivy_cache.outputs.repository }}
        ref: ${{ steps.parse_trivy_cache.outputs.ref }}
        path: trivy-db-cache
        token: ${{ inputs.trivy_db_cache_token }}

    - name: Setup Trivy DB from cache
      if: inputs.trivy_db_cache != ''
      shell: bash
      run: |
        # Create Trivy cache directory
        mkdir -p ~/.cache/trivy/db

        # Extract the DB
        cd trivy-db-cache
        tar -xvf db.tar.gz -C ~/.cache/trivy/db
        cd ..
        rm -rf trivy-db-cache

    # Issue: https://github.com/aquasecurity/trivy/issues/7938
    # Fix: Refer https://github.com/aquasecurity/trivy/discussions/7951 usign mirror.gcr.io
    - name: Generate docker-cis JSON report
      if: ${{ inputs.skip_cis_scan != 'true' && steps.meta.outputs.scan_image != '' }}
      id: cis_json
      shell: bash
      run: |
        trivy image ${{ env.input }} \
          ${{ steps.meta.outputs.scan_image }} \
          --compliance ${{ env.compliance }} \
          -f json \
          --debug \
          --ignore-unfixed \
          -o ${{ steps.meta.outputs.cis_json_file }} \
          ${{ inputs.trivy_db_cache != '' && '--cache-dir ~/.cache/trivy --skip-db-update' || '' }}
      env:
        compliance: docker-cis-1.6.0
        input: ${{ steps.docker_tar.outputs.files_exists == 'true' && '--input' || '' }}

    - name: upload docker-cis JSON report
      if: ${{ inputs.skip_cis_scan != 'true' && steps.meta.outputs.scan_image != '' }}
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
      with:
        name: ${{ steps.meta.outputs.cis_json_file }}
        path: |
          ${{ steps.meta.outputs.cis_json_file }}
        if-no-files-found: warn

    # Hack: Force Trivy to use embedded compliance checks instead of expecting CIS yaml file on-disk when cache is populated/used across multiple runs
    # Removes/clean trivy runtime generated policy/ and fanal/ folders from Cache folder
    # Refer: https://github.com/aquasecurity/trivy/blob/main/pkg/compliance/spec/compliance.go#L98C17-L108
    - name: Trivy Clean Scan Cache and Checks Bundle to use embedded checks and downloaded vuln-db
      shell: bash
      run: trivy clean --scan-cache --checks-bundle

    - name: Inspect docker-cis report
      if: ${{ inputs.skip_cis_scan != 'true' && steps.meta.outputs.scan_image != '' }}
      shell: bash
      run: |
        trivy image ${{ env.input }} \
          ${{ steps.meta.outputs.scan_image }} \
          --compliance ${{ env.compliance }} \
          -f table \
          --ignore-unfixed \
          --debug \
          ${{ inputs.trivy_db_cache != '' && '--cache-dir ~/.cache/trivy --skip-db-update' || '' }}
      env:
        compliance: docker-cis-1.6.0
        input: ${{ steps.docker_tar.outputs.files_exists == 'true' && '--input' || '' }}
